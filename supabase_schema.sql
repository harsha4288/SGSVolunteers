
-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Profiles table (linked to Supabase auth.users)
-- This table stores additional user information not covered by auth.users.
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    email TEXT UNIQUE, -- Store email here for easier querying if needed, synced from auth.users
    role TEXT NOT NULL DEFAULT 'volunteer', -- Possible roles: 'volunteer', 'team_leader', 'admin'
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);
COMMENT ON TABLE public.profiles IS 'Stores user profile information, extending Supabase auth.users. Links via the id field which is a FK to auth.users.id.';
COMMENT ON COLUMN public.profiles.id IS 'User ID, references auth.users.id.';
COMMENT ON COLUMN public.profiles.email IS 'User''s email, should be kept in sync with auth.users.email.';
COMMENT ON COLUMN public.profiles.role IS 'User role, e.g., volunteer, team_leader, admin.';

-- Volunteers table
-- This table stores all information related to volunteers, primarily sourced from Google Forms.
CREATE TABLE public.volunteers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    -- Link to a profile if the volunteer is also a system user (e.g., registered for QR code)
    user_profile_id UUID UNIQUE REFERENCES public.profiles(id) ON DELETE SET NULL,
    
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE, -- Unique email for each volunteer, critical for identification
    phone TEXT,
    gender TEXT, -- e.g., 'Male', 'Female', 'Other', or free text as per form
    
    -- Availability: Stored as JSONB for flexibility.
    -- Example: {"2024-07-08_morning": true, "2024-07-08_afternoon": false, "2024-07-09_all_day": true}
    availability JSONB,
    
    -- Details from Google Forms (can be quite specific to the event)
    seva_dates TEXT, -- Free text as submitted, e.g., "July 8th, July 9th"
    preferred_location TEXT,
    other_location TEXT, -- If their preferred location is "Other"
    is_gita_mahayajna_family BOOLEAN, -- True if "Yes", False if "No"
    association_with_mahayajna TEXT,
    mahayajna_student_name TEXT,
    student_batch TEXT, -- Batch of the student they are associated with
    hospitality_needed BOOLEAN, -- True if "Yes", False if "No" for accommodation/food
    
    vol_category TEXT, -- Broad category of volunteering, e.g., 'Event Support', 'Food Service'
    seva_task TEXT, -- Specific task/seva they signed up for, e.g., 'Registration Desk'

    additional_info TEXT, -- Any other information provided by the volunteer
    ai_tags TEXT[], -- Array of tags generated by AI for categorization and search

    google_form_submission_timestamp TIMESTAMPTZ, -- Timestamp from the Google Form if available
    created_at TIMESTAMPTZ DEFAULT now(), -- Record creation time in this DB
    updated_at TIMESTAMPTZ DEFAULT now() -- Record last update time in this DB
);
COMMENT ON TABLE public.volunteers IS 'Stores detailed information about each volunteer, typically synced from Google Forms.';
COMMENT ON COLUMN public.volunteers.user_profile_id IS 'Optional link to a system user profile (public.profiles.id) if the volunteer registers/logs in to the app.';
COMMENT ON COLUMN public.volunteers.email IS 'Unique email address for the volunteer; serves as a primary identifier.';
COMMENT ON COLUMN public.volunteers.availability IS 'JSONB field to store availability data, e.g., {"event_day_slot": true/false}.';
COMMENT ON COLUMN public.volunteers.is_gita_mahayajna_family IS 'Boolean indicating if the volunteer is part of the Gita Mahayajna family.';
COMMENT ON COLUMN public.volunteers.hospitality_needed IS 'Boolean indicating if the volunteer requires hospitality services.';
COMMENT ON COLUMN public.volunteers.ai_tags IS 'Array of text tags, potentially generated by an AI service for better categorization.';
COMMENT ON COLUMN public.volunteers.google_form_submission_timestamp IS 'Timestamp of the original form submission, if available from the source.';

-- Indexes for common query patterns
CREATE INDEX idx_volunteers_email ON public.volunteers(email);
CREATE INDEX idx_volunteers_name ON public.volunteers(first_name, last_name);
CREATE INDEX idx_volunteers_user_profile_id ON public.volunteers(user_profile_id);
CREATE INDEX idx_volunteers_ai_tags ON public.volunteers USING GIN (ai_tags); -- For array searching
CREATE INDEX idx_volunteers_availability ON public.volunteers USING GIN (availability); -- For JSONB searching


-- T-Shirt Inventory table
-- Tracks the number of T-shirts available for each size.
CREATE TABLE public.tshirt_inventory (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    size TEXT NOT NULL UNIQUE, -- T-shirt size, e.g., 'S', 'M', 'L', 'XL'. Unique constraint assumes one type of event/T-shirt batch.
    initial_quantity INTEGER NOT NULL DEFAULT 0,
    remaining_quantity INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);
COMMENT ON TABLE public.tshirt_inventory IS 'Tracks T-shirt stock by size for the event.';
COMMENT ON COLUMN public.tshirt_inventory.size IS 'Unique T-shirt size identifier (e.g., S, M, L, XL).';
COMMENT ON COLUMN public.tshirt_inventory.initial_quantity IS 'The initial number of T-shirts available for this size.';
COMMENT ON COLUMN public.tshirt_inventory.remaining_quantity IS 'The current number of T-shirts available for this size.';

-- Ensure remaining_quantity is not negative
ALTER TABLE public.tshirt_inventory ADD CONSTRAINT check_remaining_quantity_non_negative CHECK (remaining_quantity >= 0);

-- T-Shirt Issuances table
-- Logs each time a T-shirt is issued to a volunteer.
CREATE TABLE public.tshirt_issuances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    volunteer_id UUID NOT NULL REFERENCES public.volunteers(id) ON DELETE CASCADE,
    tshirt_inventory_id UUID NOT NULL REFERENCES public.tshirt_inventory(id) ON DELETE RESTRICT, -- Links to the specific T-shirt size/item from inventory
    issued_at TIMESTAMPTZ DEFAULT now(),
    issued_by_profile_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL, -- ID of the help desk staff/admin who logged the issuance
    method TEXT NOT NULL, -- How the T-shirt was issued, e.g., 'qr_scan', 'manual_entry'
    notes TEXT, -- Optional notes about the issuance
    created_at TIMESTAMPTZ DEFAULT now()
    -- No updated_at here as issuances are generally immutable; corrections would be new entries or specific handling.
);
COMMENT ON TABLE public.tshirt_issuances IS 'Logs each T-shirt issuance to a volunteer, linking to the volunteer and the T-shirt inventory item.';
COMMENT ON COLUMN public.tshirt_issuances.volunteer_id IS 'ID of the volunteer receiving the T-shirt.';
COMMENT ON COLUMN public.tshirt_issuances.tshirt_inventory_id IS 'ID of the T-shirt inventory item (specifies size).';
COMMENT ON COLUMN public.tshirt_issuances.issued_by_profile_id IS 'ID of the user (e.g., help desk staff) who performed the issuance.';
COMMENT ON COLUMN public.tshirt_issuances.method IS 'Method of issuance, e.g., "qr_scan", "manual_entry".';

CREATE INDEX idx_tshirt_issuances_volunteer_id ON public.tshirt_issuances(volunteer_id);
CREATE INDEX idx_tshirt_issuances_tshirt_inventory_id ON public.tshirt_issuances(tshirt_inventory_id);

-- Volunteer Check-ins table
-- Records volunteer attendance as marked by team leaders.
CREATE TABLE public.volunteer_check_ins (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    volunteer_id UUID NOT NULL REFERENCES public.volunteers(id) ON DELETE CASCADE,
    event_day DATE NOT NULL, -- The specific date of the event for this check-in
    shift_slot TEXT NOT NULL, -- Description of the shift, e.g., 'Morning Shift (9 AM - 1 PM)', 'Afternoon Shift (1 PM - 5PM)'
    task_assigned TEXT, -- Specific task the volunteer is checking in for (if applicable)
    checked_in_at TIMESTAMPTZ DEFAULT now(),
    checked_in_by_profile_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL, -- Team leader who marked attendance
    notes TEXT, -- Optional notes by the team leader
    created_at TIMESTAMPTZ DEFAULT now()
    -- No updated_at here as check-ins are typically point-in-time records.
);
COMMENT ON TABLE public.volunteer_check_ins IS 'Records volunteer attendance for specific event days and shifts, marked by team leaders.';
COMMENT ON COLUMN public.volunteer_check_ins.volunteer_id IS 'ID of the volunteer being checked in.';
COMMENT ON COLUMN public.volunteer_check_ins.event_day IS 'The date of the check-in.';
COMMENT ON COLUMN public.volunteer_check_ins.shift_slot IS 'The shift or time slot the volunteer is checking in for (e.g., "Morning", "Afternoon", "Full Day").';
COMMENT ON COLUMN public.volunteer_check_ins.task_assigned IS 'The task the volunteer was assigned for this shift.';
COMMENT ON COLUMN public.volunteer_check_ins.checked_in_by_profile_id IS 'ID of the team leader (from public.profiles) who performed the check-in.';

CREATE INDEX idx_volunteer_check_ins_volunteer_id ON public.volunteer_check_ins(volunteer_id);
CREATE INDEX idx_volunteer_check_ins_event_day ON public.volunteer_check_ins(event_day);
CREATE INDEX idx_volunteer_check_ins_checked_in_by ON public.volunteer_check_ins(checked_in_by_profile_id);


-- Function to automatically update `updated_at` timestamp columns
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers to update `updated_at` on relevant tables
CREATE TRIGGER set_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();

CREATE TRIGGER set_volunteers_updated_at
BEFORE UPDATE ON public.volunteers
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();

CREATE TRIGGER set_tshirt_inventory_updated_at
BEFORE UPDATE ON public.tshirt_inventory
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();

-- Trigger to decrement T-shirt quantity in inventory upon issuance
CREATE OR REPLACE FUNCTION decrement_tshirt_inventory_quantity()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.tshirt_inventory
  SET remaining_quantity = remaining_quantity - 1
  WHERE id = NEW.tshirt_inventory_id AND remaining_quantity > 0;

  IF NOT FOUND THEN
     -- This checks if the update actually happened (i.e., remaining_quantity was > 0)
     -- Re-fetch to confirm current state for accurate error message
     DECLARE
        current_quantity INTEGER;
        current_size TEXT;
     BEGIN
        SELECT ti.remaining_quantity, ti.size INTO current_quantity, current_size FROM public.tshirt_inventory ti WHERE ti.id = NEW.tshirt_inventory_id;
        IF current_quantity <= 0 THEN
            RAISE EXCEPTION 'T-shirt size % is out of stock.', current_size;
        ELSE
            -- This case should ideally not be reached if FK constraint is working and item exists
            RAISE EXCEPTION 'T-shirt inventory item with ID % not found or invalid state.', NEW.tshirt_inventory_id;
        END IF;
     END;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_tshirt_issuance_decrement_stock
AFTER INSERT ON public.tshirt_issuances
FOR EACH ROW
EXECUTE FUNCTION decrement_tshirt_inventory_quantity();


-- Optional: Trigger to increment T-shirt quantity if an issuance record is deleted (e.g. data correction)
-- This can be complex if updates are allowed; for append-only or controlled deletion, it's simpler.
CREATE OR REPLACE FUNCTION increment_tshirt_inventory_quantity_on_delete()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.tshirt_inventory
  SET remaining_quantity = remaining_quantity + 1
  WHERE id = OLD.tshirt_inventory_id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- CREATE TRIGGER before_tshirt_issuance_delete_increment_stock
-- AFTER DELETE ON public.tshirt_issuances
-- FOR EACH ROW
-- EXECUTE FUNCTION increment_tshirt_inventory_quantity_on_delete();
-- Commented out delete trigger by default to simplify initial setup. Enable if robust undo is needed.

-- RLS (Row Level Security) Policies
-- Enable RLS for all tables by default. Specific policies will be defined per table.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.volunteers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tshirt_inventory ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tshirt_issuances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.volunteer_check_ins ENABLE ROW LEVEL SECURITY;

-- Example RLS policies (adjust based on actual auth roles and logic):

-- Profiles: Users can view their own profile. Admins can view all.
CREATE POLICY "Users can view their own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Admins can manage all profiles" ON public.profiles
  FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin'))
  WITH CHECK (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin'));


-- Volunteers: Authenticated users can view all (if that's the requirement). Admins can manage all.
CREATE POLICY "Authenticated users can view volunteer data" ON public.volunteers
  FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Admins can manage all volunteer data" ON public.volunteers
  FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin'))
  WITH CHECK (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin'));

-- T-Shirt Inventory: Authenticated users can view. Admins/Team Leaders can manage.
CREATE POLICY "Authenticated users can view T-shirt inventory" ON public.tshirt_inventory
  FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Admins or Team Leaders can manage T-shirt inventory" ON public.tshirt_inventory
  FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND (role = 'admin' OR role = 'team_leader')))
  WITH CHECK (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND (role = 'admin' OR role = 'team_leader')));

-- T-Shirt Issuances:
-- Volunteers can see their own issuances. Team Leaders/Admins can see all and create.
CREATE POLICY "Volunteers can view their own T-shirt issuances" ON public.tshirt_issuances
  FOR SELECT USING (EXISTS (SELECT 1 FROM public.volunteers v WHERE v.id = volunteer_id AND v.user_profile_id = auth.uid()));
CREATE POLICY "Admins or Team Leaders can manage T-shirt issuances" ON public.tshirt_issuances
  FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND (role = 'admin' OR role = 'team_leader')))
  WITH CHECK (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND (role = 'admin' OR role = 'team_leader')));


-- Volunteer Check-ins:
-- Team Leaders can manage check-ins. Admins can manage all. Authenticated users can view all (or specific subsets).
CREATE POLICY "Authenticated users can view check-in data" ON public.volunteer_check_ins
  FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Admins or Team Leaders can manage check-ins" ON public.volunteer_check_ins
  FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND (role = 'admin' OR role = 'team_leader')))
  WITH CHECK (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND (role = 'admin' OR role = 'team_leader')));

-- Default data seeding (example for T-shirt sizes)
-- This should be run once after table creation if needed.
-- INSERT INTO public.tshirt_inventory (size, initial_quantity, remaining_quantity) VALUES
-- ('S', 200, 200),
-- ('M', 300, 300),
-- ('L', 300, 300),
-- ('XL', 150, 150),
-- ('XXL', 50, 50)
-- ON CONFLICT (size) DO NOTHING; -- Prevents error if sizes already exist

-- Note: Initial data for volunteers will come from Google Forms sync.
-- Ensure roles like 'admin' and 'team_leader' are assigned to appropriate users in the `profiles` table.
-- Example: UPDATE public.profiles SET role = 'admin' WHERE email = 'admin_user@example.com';

